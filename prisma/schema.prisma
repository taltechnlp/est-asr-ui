generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model File {
  id                       String                 @id @db.VarChar(30)
  state                    String                 @default("UPLOADED")
  text                     String?
  path                     String
  filename                 String
  duration                 Decimal?
  uploadedAt               DateTime?
  mimetype                 String
  encoding                 String
  externalId               String?
  textTitle                String?
  initialTranscriptionPath String?
  initialTranscription     String?
  uploader                 String?                @db.VarChar(30)
  language                 String
  notified                 Boolean?
  notify                   Boolean?
  autoAnalyze              Boolean?
  analysisStatus           String?                 @default("not_started")
  originalAsrData          String?
  diffsGenerated           Boolean?                @default(false)
  analysisSegments         AnalysisSegment[]
  chatSessions             ChatSession[]
  User                     User?                  @relation(fields: [uploader], references: [id], onDelete: Cascade, onUpdate: NoAction)
  workflows                NfWorkflow[]
  transcriptCorrections    TranscriptCorrection[]
  transcriptSummary        TranscriptSummary?
}

model Account {
  id                    String    @id
  userId                String
  type                  String    @default("oauth")
  provider              String
  providerAccountId     String
  scope                 String?
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@unique([provider, providerAccountId], map: "Account_provider_providerAccountId_key")
  @@map("account")
}

model Session {
  id        String   @id
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model User {
  id               String        @id @db.VarChar(30)
  email            String        @unique(map: "default$default.User.email._UNIQUE")
  name             String
  password         String?
  resetToken       String?
  resetTokenExpiry BigInt?
  role             Role          @default(USER)
  emailVerified    DateTime?
  image            String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  chatSessions     ChatSession[]
  files            File[]
  accounts         Account[]
  sessions         Session[]

  @@map("user")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt

  @@map("verification")
}

model NfWorkflow {
  run_id         String      @unique
  run_name       String      @unique
  file_id        String
  event          NfEvent
  utc_time       DateTime
  failedCount    Int?
  pendingCount   Int?
  progressLength Int?
  runningCount   Int?
  succeededCount Int?
  processes      NfProcess[]
  file           File        @relation(fields: [file_id], references: [id], onDelete: Cascade)
}

model NfProcess {
  id          String     @id @default(cuid())
  task_id     Int
  process     String
  tag         String?
  hash        String
  status      NfStatus
  submit      DateTime?
  cpu         Float?
  mem         Float?
  peak_rss    Float?
  peak_vmem   Float?
  rchar       Float?
  wchar       Float?
  vol_ctxt    Int?
  inv_ctxt    Int?
  workflow_id String
  start       DateTime?
  exit        DateTime?
  duration    Int?
  realtime    Int?
  complete    DateTime?
  workflow    NfWorkflow @relation(fields: [workflow_id], references: [run_id], onDelete: Cascade)
}

model ChatSession {
  id        String   @id @default(cuid())
  fileId    String
  userId    String
  messages  Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  file      File     @relation(fields: [fileId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([fileId])
  @@index([userId])
}

model TranscriptSummary {
  id               String   @id @default(cuid())
  fileId           String   @unique
  summary          String
  keyTopics        String[]
  speakerCount     Int
  language         String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  displaySummary   String?
  uiLanguage       String?
  displayKeyTopics String[] @default([])
  file             File     @relation(fields: [fileId], references: [id], onDelete: Cascade)
}

model AnalysisSegment {
  id               String   @id @default(cuid())
  fileId           String
  segmentIndex     Int
  startTime        Float
  endTime          Float
  startWord        Int
  endWord          Int
  originalText     String
  analysis         String
  suggestions      Json
  nBestResults     Json?
  status           String   @default("pending")
  createdAt        DateTime @default(now())
  speakerName      String?
  correctedSegment String?
  file             File     @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([fileId, segmentIndex])
  @@index([fileId])
}

model TranscriptCorrection {
  id               String   @id @default(cuid())
  fileId           String
  blockIndex       Int
  segmentIndices   Int[]
  originalText     String
  correctedText    String?
  suggestions      Json     @default("[]")
  llmInteractions  Json     @default("[]")
  processingTimeMs Int?
  status           String   @default("pending")
  error            String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  file             File     @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([fileId, blockIndex])
  @@index([fileId])
  @@index([fileId, status])
}

enum Role {
  USER
  ADMIN
}

enum NfStatus {
  PENDING
  SUBMITTED
  RUNNING
  CACHED
  COMPLETED
  ERROR
  FAILED
  ABORTED
}

enum NfEvent {
  started
  process_submitted
  process_started
  process_completed
  error
  completed
}
